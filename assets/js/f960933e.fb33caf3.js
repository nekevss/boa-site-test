"use strict";(self.webpackChunkboajs_dev=self.webpackChunkboajs_dev||[]).push([[2934],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var u=a.createContext({}),p=function(e){var t=a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},s=function(e){var t=p(e.components);return a.createElement(u.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,u=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),c=p(n),m=i,h=c["".concat(u,".").concat(m)]||c[m]||d[m]||o;return n?a.createElement(h,r(r({ref:t},s),{},{components:n})):a.createElement(h,r({ref:t},s))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l[c]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7885:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const o={sidebar_position:3},r="Tracing Boa's Virtual Machine",l={unversionedId:"debugging/debug_trace",id:"debugging/debug_trace",title:"Tracing Boa's Virtual Machine",description:'Please note: to run trace, boa needs to have the "trace" feature flag.',source:"@site/docs/debugging/debug_trace.md",sourceDirName:"debugging",slug:"/debugging/debug_trace",permalink:"/boa-site-test/docs/debugging/debug_trace",draft:!1,editUrl:"https://github.com/boa-dev/boa-dev.github.io/tree/main/docs/docs/debugging/debug_trace.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"infoSidebar",previous:{title:"Debugging Tokens and AST nodes",permalink:"/boa-site-test/docs/debugging/debug_tokens_ast"},next:{title:"VM Execution Flowgraph",permalink:"/boa-site-test/docs/debugging/debug_flowgraph"}},u={},p=[{value:"Understanding Boa&#39;s Trace Output",id:"understanding-boas-trace-output",level:2},{value:"Comparing Trace Output",id:"comparing-trace-output",level:3}],s={toc:p},c="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(c,(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"tracing-boas-virtual-machine"},"Tracing Boa's Virtual Machine"),(0,i.kt)("p",null,'Please note: to run trace, boa needs to have the "trace" feature flag.'),(0,i.kt)("p",null,"Once the AST has been generated, boa will compile it into bytecode, which is then executed by the VM.\nYou can print the bytecode and the executed instructions with the command-line flag ",(0,i.kt)("inlineCode",{parentName:"p"},"--trace"),"."),(0,i.kt)("h2",{id:"understanding-boas-trace-output"},"Understanding Boa's Trace Output"),(0,i.kt)("p",null,'Once you have boa installed or setup with the "trace" feature flag, try some simple ECMAScript/JS in a test file.'),(0,i.kt)("p",null,"Let's walkthrough an example of how to trace from a cloned boa repo."),(0,i.kt)("p",null,'Add the below code into a "test.js" file in the project root.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="test.js"',title:'"test.js"'},"//\nlet a = 1;\nlet b = 2;\n")),(0,i.kt)("p",null,"Then run the below command-line:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"cargo run -- --test.js --trace\n")),(0,i.kt)("p",null,"Boa will now compile and run ",(0,i.kt)("inlineCode",{parentName:"p"},"test.js"),", which will output the below trace to ",(0,i.kt)("inlineCode",{parentName:"p"},"stdout"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"----------------------Compiled Output: '<main>'-----------------------\nLocation  Count   Opcode                     Operands\n\n000001    0000    PushOne\n000006    0001    DefInitLet                 0000: 'a'\n000008    0002    PushInt8                   2\n000013    0003    DefInitLet                 0001: 'b'\n\nLiterals:\n    <empty>\n\nBindings:\n    0000: a\n    0001: b\n\nFunctions:\n    <empty>\n\n\n------------------------------------------ VM Start ------------------------------------------\nTime          Opcode                     Operands                   Top Of Stack\n\n386\u03bcs         PushOne                                               1\n6\u03bcs           DefInitLet                 0000: 'a'                  <empty>\n1\u03bcs           PushInt8                   2                          2\n2\u03bcs           DefInitLet                 0001: 'b'                  <empty>\n\nStack:\n    <empty>\n\n\nundefined\n")),(0,i.kt)("p",null,"The above output contains the following information:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The bytecode and properties of the function that will be executed",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Compiled Output"),": The bytecode.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Location"),": Location of the instruction (instructions are not the same size)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Count"),": Instruction count."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Opcode"),": Opcode name."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Operands"),": The operands of the opcode."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Literals"),": The literals used by the bytecode (like strings)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Bindings"),": Binding names used by the bytecode."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Functions"),": Function names use by the bytecode."))),(0,i.kt)("li",{parentName:"ul"},"The code being executed (marked by ",(0,i.kt)("inlineCode",{parentName:"li"},"Vm Start")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"Call Frame"),").",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Time"),": The amount of time that instruction took to execute."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Opcode"),": Opcode name."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Operands"),": The operands of the opcode."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Top Of Stack"),": The top element of the stack ",(0,i.kt)("strong",{parentName:"li"},"after")," execution of instruction."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Stack"),": The trace of the stack after execution ends."),(0,i.kt)("li",{parentName:"ul"},"The result of the execution (The top element of the stack, if the stack is empty then ",(0,i.kt)("inlineCode",{parentName:"li"},"undefined")," is returned).")),(0,i.kt)("h3",{id:"comparing-trace-output"},"Comparing Trace Output"),(0,i.kt)("p",null,"If you wanted another engine's bytecode output for the same JS, SpiderMonkey's bytecode output is the best to use. You can follow the setup ",(0,i.kt)("a",{parentName:"p",href:"https://udn.realityripple.com/docs/Mozilla/Projects/SpiderMonkey/Introduction_to_the_JavaScript_shell"},"here"),". You will need to build from source because the pre-built binarys don't include the debugging utilities which we need."),(0,i.kt)("p",null,"NOTE: The binary was renamed as ",(0,i.kt)("inlineCode",{parentName:"p"},"js_shell")," due to ",(0,i.kt)("inlineCode",{parentName:"p"},"js")," conflicting with NodeJS."),(0,i.kt)("p",null,"Once up and running you should be able to use ",(0,i.kt)("inlineCode",{parentName:"p"},"js_shell -f tests/js/test.js"),". You will get no output to begin with, this is because you need to run ",(0,i.kt)("inlineCode",{parentName:"p"},"dis()")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"dis([func])")," in the code. Once you've done that you should get some output like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},'loc     op\n-----   --\n00000:  GlobalOrEvalDeclInstantiation 0 #\nmain:\n00005:  One                             # 1\n00006:  InitGLexical "a"                # 1\n00011:  Pop                             #\n00012:  Int8 2                          # 2\n00014:  InitGLexical "b"                # 2\n00019:  Pop                             #\n00020:  GetGName "dis"                  # dis\n')))}d.isMDXComponent=!0}}]);